# Reflection — 2025-12-20 — Cascade Mode

## Контекст задачи
Нужно было внедрить режим **каскада**: внутри одного спина повторяем поиск выигрышной комбинации, удаляем только карты из комбинации, добираем новые, повторяем до отсутствия комбинаций; выигрыш суммируется и начисляется на баланс **одним платежом** в конце. Также нужно было сделать **переключение режимов** (Normal/Cascade) с сохранением выбора.

## План vs фактическая реализация
- **План** (в `memory-bank/tasks.md`): добавить режим, чистую логику каскада в application, оркестрацию в UI-контроллере, UI переключателя и индикации, гейты `test/lint/build`.
- **Факт**:
  - Добавлен `GameMode` + сохранение в `localStorage`.
  - Сделана чистая логика каскада в application:
    - `buildCascadeSequenceUseCase` (первый подход).
    - затем добавлен `applyCascadeStepUseCase` для пошагового расчёта, чтобы связать расчёт с визуальным таймлайном и убрать рассинхроны.
  - В `useBalatroInfernoController` реализован каскадный таймлайн (баннер → скрытие → vanish → пустые слоты → drop-in новых карт → следующий шаг).
  - В UI добавлены переключатель режима и HUD для каскада.
  - Добавлен debug overlay (toggle `D`) для диагностики рассинхронов (computed vs display).
  - Финальный UX скорректирован: на завершении каскада показываем **TOTAL WIN**, а не “последнюю выигрышную комбинацию” поверх финальной (часто проигрышной) руки.
  - Гейты стабильно зелёные: `npm run test`, `npm run lint`, `npm run build`.

## Что оказалось сложным
- **Рассинхроны UI ↔ логика** из-за таймеров и промежуточных состояний руки (null-слоты, поштучное появление карт).
- **Эффекты и зависимости React**: некоторые обновления (deck/dealIndex/hand) приводили к повторным запускам эффекта каскада и “залипанию” подсветок/баннера.
- **UX финала каскада**: “последняя выигрышная комбинация” не соответствует финальной руке, что воспринимается как неверный расчёт.

## Что сработало хорошо
- Разделение на **application use-cases** и UI-оркестрацию помогло тестировать логику отдельно.
- Детерминированные unit-тесты на use-cases дали уверенность, что “математика” не сломалась.
- Debug overlay (computed vs display) быстро показал, что часть “неверности” была UX/синхронизацией, а не `getBestHand`.

## Что улучшить в процессе
- Сразу закладывать **наблюдаемость** (debug режим) для анимационных игровых механик.
- Делать каскадную логику “пошаговой” раньше (как финальный вариант) — меньше риска гонок.
- Явно документировать, что показываем в финале: “TOTAL WIN” vs “final hand result”, чтобы избежать путаницы.

## Следующие шаги (если продолжать)
- Решить судьбу debug overlay (оставить как dev‑фичу/спрятать за флагом/убрать перед релизом).
- Улучшить анимации “исчезновения” в стиле проекта (электро‑распад/пиксель‑диссольв).
- Добавить (опционально) множители каскада и/или более богатую индикацию шагов.


