# Рефлексия — refactor (cascade scheduler/state) + финальная документация (Docs)

Дата: 2025‑12‑23

## 1) План vs фактическая реализация

### План (как договаривались)
- Провести аудит/перф baseline, затем маленькими шагами рефакторить без изменения поведения.
- `refactor-1`: упорядочить таймеры каскада (единый scheduler поверх clock) без изменения поведения.
- `refactor-2`: минимально структурировать cascade state (фазы/токены), добавить регрессионные проверки на `fakeClock`.
- После завершения рефакторинга — написать финальную документацию.
- Процессно: маленькие шаги, откат при нежелательном визуале, частые апдейты Memory Bank.

### Факт (что сделали)
- `refactor-1` выполнен:
  - введён единый scheduler с token‑guard и централизованным cleanup для каскадных таймеров в `useBalatroInfernoController`.
  - гейт: Vitest зелёный.
- `refactor-2` выполнен:
  - введён `cascadePhaseRef` (фазы каскада через `ref`, UI на это не завязан).
  - вынесены тестируемые утилиты `scheduler.js` и `cascadeTimeline.js`.
  - добавлен регрессионный тест `cascadeTimeline.test.ts` на `fakeClock`.
  - гейты: Vitest зелёный, build зелёный, lint зелёный.
- Документация:
  - обновлён корневой `README.md` (убран устаревший entrypoint).
  - добавлена и заполнена папка `Docs/` (архитектура, флоу/таймлайн, профилирование, перфоманс, тестирование, деплой).
  - расширение до “максимально подробно”: добавлены `Docs/faq.md` и `Docs/glossary.md`, расширен `Docs/architecture.md` (карта директорий, правила зависимостей, чеклист “куда класть код”, диаграмма).
- Процессные правила закреплены в Memory Bank:
  - перед REFLECT обновлять `Docs/` там, где нужно
  - на PLAN/BUILD всегда сверяться с `Docs/architecture.md` (“куда класть код”)

## 2) Что сделали (коротко, по сути)

### Рефакторинг каскада (без изменения поведения)
- Убрали “разрозненность” таймеров: единый scheduler поверх `deps.clock`, единый cleanup, guard по токену.
- Вытащили refill‑таймлайн в отдельную чистую функцию и покрыли тестом на fake clock (детерминизм).
- Добавили ref‑фазы каскада для более явной структуры таймлайна и отладки (без влияния на UI).

### Документация (финальная)
- Вынесли финальную документацию в `Docs/` и связали её с корневым `README.md`.
- Добавили “процессные” документы (FAQ и глоссарий) для ускорения онбординга и снижения “вопросов по кругу”.

## 3) Что было сложным / почему

- **Таймлайн каскада**: много таймеров, высокая цена ошибки (гонки/устаревшие callbacks).
  - Решение: token‑guard + централизованный `clearAll()`.
- **Тестирование таймингов**:
  - В первом прогоне тест упал из‑за неверного expected (ошибка в тесте, а не в логике), но это было полезно — сразу зафиксировали формулу таймингов.
- **Окружение тестов (sandbox)**:
  - ранее проявлялся `EPERM kill` у Vitest; держим в доках “безболезненный” режим запуска одним воркером.

## 4) Что оказалось удачным

- **DI для зависимостей контроллера** (rng/clock/storage/location): улучшило “чистоту” границ и тестируемость.
- **Вынос таймлайна в чистые утилиты**:
  - стало проще читать контроллер
  - появилось место для регресс‑тестов без React
- **Процессные правила в Memory Bank**:
  - снижает шанс, что следующий агент начнёт “планировать фичу” и положит код не в тот слой
  - гарантирует актуальность `Docs/` перед REFLECT/ARCHIVE
- **Документация как отдельный артефакт `Docs/`**:
  - отделили финальное описание проекта от “рабочих заметок” (memory-bank).

## 5) Что можно улучшить в процессе (следующий раз)

- Перед “максимально подробной” документацией фиксировать:
  - целевую аудиторию (новый разработчик / будущий я / open-source)
  - глубину (вплоть до code references / примеров)
- Для перф‑работ:
  - хранить “baseline сценарии” и артефакты профилирования (имена файлов, дата, режим: dev/prod, кеш: cold/warm) в одном месте, чтобы сравнивать честно.
- Для каскада:
  - со временем можно добавить ещё 1–2 регресс‑теста на “finish(no-win)” и “finish(deck-shortage)” (через fake clock), если каскад будет дальше усложняться.

## 6) Итог

Рефакторинг каскада выполнен безопасно (без изменения поведения), таймлайны стали структурнее и тестируемее. Финальная документация создана и дополнена процессными правилами, чтобы удерживать архитектурные границы и актуальность описания проекта.


